# Pumpkin Runtime Architecture

> **Status:** Draft
> **Version:** 0.1
> **Author:** Antigravity

## 1. Overview

This document defines the runtime architecture for **Pumpkin v0.1**.
Pumpkin is an interpreted, dynamically typed toy language designed for education. The runtime is built in **TypeScript** and executes directly from the developer's terminal using **Node.js**.

## 2. Design Constraints

* **No Compilation:** Source code is executed directly (tree-walking interpreter).
* **Host Environment:** Node.js (provides Event Loop, File I/O, Console).
* **Correctness over Speed:** Focus on helpful error messages and predictable execution flow rather than JIT/optimization.
* **Deterministic:** The same code must produce the same output every time.

## 3. System Modules

The runtime is divided into distinct execution stages:

```mermaid
graph TD
    A[Source Code (.pumpkin)] -->|Read| B[Parser (Ohm.js)];
    B -->|MatchResult| C{Valid Syntax?};
    C -- No --> D[Syntax Error Handler];
    C -- Yes --> E[Interpreter (Tree Walker)];
    E <--> F[Environment (Scope/Vars)];
    E --> G[Standard Library];
    D --> H[Friendly Error Output];
    E --> H;
    G --> H;
```

### 3.1. Module Descriptions

| Module | Responsibility |
| :--- | :--- |
| **CLI (`src/cli.ts`)** | Entry point. Handles arguments, flags, and switches between File/REPL modes. |
| **Parser (`src/parser.ts`)** | Wraps `ohm-js`. Converts raw text into a Concrete Syntax Tree (CST) or CST-Semantics object. |
| **Interpreter (`src/interpreter.ts`)** | The "brain". Traverses the semantics tree and executes logic node-by-node. |
| **Environment (`src/environment.ts`)** | Manages memory. Handles variable storage (`let`), assignment, and scope nesting (blocks/functions). |
| **Error System (`src/errors.ts`)** | Captures raw errors and transforms them into Pumpkin's truncated "What/Why/Fix" format. |
| **StdLib (`src/stdlib/`)** | Native TypeScript implementations of execution-ready functions (e.g., `show`, `math.add`). |

## 4. Execution Model

### 4.1. The Tree-Walker

Pumpkin uses a **Tree-Walking Interpreter**. Instead of compiling code to bytecode or machine code, the interpreter recursively visits nodes in the parse tree generated by Ohm.

**Mechanism:**

1. **Grammar Matching:** The code is matched against `pumpkin.ohm`.
2. **Semantics visitor:** An Ohm `Semantics` object is defined with an `execute()` operation.
3. **Traversal:**
    * Root node (`Program`) calls `execute()` on its children (`Statement+`).
    * A `Statement` (e.g., `IfStmt`) evaluates its expression nodes (`Exp`).
    * Expression nodes return **Runtime Values** (Numbers, Strings, etc.).
    * Control flow nodes (`If`, `Loop`) conditionally execute their child Blocks.

### 4.2. Program Lifecycle

1. **Startup:** User runs `pumpkin my_script.pumpkin`.
2. **Load:** CLI reads file content into string buffer.
3. **Parse:** Ohm attempts to match the entire string to the `Program` rule.
    * *Failure:* Throw `SyntaxError`.
    * *Success:* Return `MatchResult`.
4. **Interpret:**
    * Create global `Environment`.
    * Load `StdLib` into global environment.
    * Invoke `interpreter.run(matchResult)`.
5. **Shutdown:** Process exits with code 0 (success) or 1 (runtime error).

## 5. Environment & State Management

### 5.1. The `Environment` Class

The state is managed via a chain of Environment objects.

```typescript
type PumpkinValue = number | string | boolean | PumpkinObject | PumpkinList | FunctionVal;

interface Environment {
  // Storage for current scope
  values: Map<string, PumpkinValue>;
  // Reference to parent scope (undefined for global)
  parent?: Environment;

  // API
  declare(name: string, value: PumpkinValue): void; // 'let'
  assign(name: string, value: PumpkinValue): void;  // '='
  get(name: string): PumpkinValue;                  // Variable access
}
```

### 5.2. Scoping Rules

* **Lexical Scoping:** Inner blocks can access outer variables.
* **Shadowing:** Inner scopes can declare variables with the same name as outer scopes (effectively hiding the outer one).
* **Function Closure:** When a function is declared, it captures the *definition-time* environment.

## 6. Error Propagation System

Pumpkin errors are distinct from JS errors. They must be intercepted and formatted.

**Error Types:**

1. **Syntax Errors:** Caught during Parse phase. (e.g., missing brace).
2. **Runtime Errors:** Caught during Interpret phase. (e.g., dividing by zero, variable not found).
3. **Internal Errors:** Bugs in the interpreter itself (should rarely happen).

**The `PumpkinError` Class:**

```typescript
class PumpkinError extends Error {
  constructor(
    public type: 'Syntax' | 'Runtime',
    public message: string, // "What happened"
    public cause: string,   // "Why"
    public suggestion: string // "How to fix"
  ) { ... }
}
```

**Flow:**
Interpreter `try/catch` wrapper -> Catches JS Error -> Maps to `PumpkinError` -> CLI pretty-prints -> Exit.

## 7. REPL vs File Execution

### File Mode (`pumpkin file.pk`)

* **Input:** Entire file string.
* **Scope:** Single global scope created at start.
* **Failure:** Any error terminates the process immediately.

### REPL Mode (`pumpkin` shell)

* **Input:** Read line-by-line (using node `readline`).
* **Scope:** **Persistent Global Environment**.
  * The environment is created *once* at startup.
  * Each line is parsed and executed as a standalone `Statement` or `Exp`.
  * Variables declared in previous lines remain available.
* **Failure:** Errors print the message but **do not** terminate the process. The prompt returns for the next input.

## 8. Data Flow Diagram (Text)

```text
[User Input]
     |
     v
(CLI Router) --(is file)--> [File Loader] --> (Source String)
     |                                             |
  (is REPL)                                        v
     |                                      [Parse (Ohm)]
     |                                             |
[Readline Loop] --> (Line String) --> [Parse] --> (MatchResult)
     |                                             |
     ^ <----------------(Error)------------------- +
     |                                             |
     ^ <----------------(Success)----------------- v
     |                                     [Interpreter walker]
     |                                             |
     |                                     +-------+-------+
     |                                     |               |
     |                               (Read/Write)      (Call)
     |                                     |               |
     |                              [Environment]      [StdLib]
     |                                     |               |
     + <-----------(Output Result)---------+---------------+
```
