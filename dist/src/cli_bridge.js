// src/cli_bridge.ts (Mockup)
/*
    IMPORTANT: This file requires `pumpkin_core.wasm` to be built first.
    It demonstrates how to load and execute the WASM module from Node.js environment.
*/
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
const __dirname = fileURLToPath(new URL('.', import.meta.url));
// @ts-ignore - This file is generated by wasm-pack
import { PumpkinVM } from '../pumpkin_core/pkg/pumpkin_core.js';
// Assume we have a function to get AST from source
// import { parseToAST } from './parser'; 
export async function executePumpkinScript(filePath) {
    console.log(`ðŸŽƒ Executing ${filePath} via Rust Core...`);
    // 1. Initialize VM (WASM is auto-loaded by the nodejs target bridge)
    const vm = new PumpkinVM();
    // 4. Read Source & Parse (Mocked here)
    const _sourceCode = fs.readFileSync(filePath, 'utf-8');
    const mockAst = {
        kind: "Program",
        body: [
            {
                kind: "ShowStmt",
                expression: {
                    kind: "Literal",
                    value: "Hello from Rust!",
                    raw: "\"Hello from Rust!\"",
                    loc: null
                },
                loc: null
            }
        ],
        loc: null
    };
    // 5. Run it!
    const result_js = vm.run(JSON.stringify(mockAst));
    // 6. Handle Result
    // The result is a plain JS object matching ExecutionResult interface
    if (result_js.success) {
        // Print captured output to stdout
        if (result_js.output && Array.isArray(result_js.output)) {
            result_js.output.forEach((line) => console.log(line));
        }
    }
    else {
        // Print error to stderr
        console.error("ðŸ’¥ Execution Failed:");
        if (result_js.error) {
            // Pretty print based on error kind
            console.error(JSON.stringify(result_js.error, null, 2));
        }
        process.exit(1);
    }
}
//# sourceMappingURL=cli_bridge.js.map